generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Channel {
  id           String               @id @default(uuid())
  type         ChannelType          @default(group)
  name         String
  description  String?
  ownerId      String               @map("created_by")
  createdAt    DateTime             @default(now()) @map("created_at")
  avatar       String?
  updatedAt    DateTime             @updatedAt @map("updated_at")
  isActive     Boolean?             @default(true)
  deletedAt    DateTime?            @db.Timestamp(6)
  owner        User                 @relation("ChannelOwner", fields: [ownerId], references: [id])
  participants ChannelParticipant[]
  messages     Message[]
}

model ChannelParticipant {
  id            String       @id @default(uuid())
  channelId     String
  userId        String
  role          MemberRole   @default(member)
  joinedAt      DateTime     @default(now())
  leftAt        DateTime?
  isMuted       Boolean      @default(false)
  isPinned      Boolean      @default(false)
  lastMessageAt DateTime?
  lastReadAt    DateTime?
  unreadCount   Int          @default(0)
  status        MemberStatus @default(joined)
  channel       Channel      @relation(fields: [channelId], references: [id], onDelete: Cascade)
  user          User         @relation(fields: [userId], references: [id], onDelete: Cascade, onUpdate: NoAction)

  @@unique([channelId, userId])
}

model Message {
  id                String              @id @default(uuid())
  channelId         String
  senderId          String
  receiverId        String?
  sessionId         String?
  messageType       MessageType         @default(text)
  message           String?
  metadata          Json?
  status            String              @default("queued")
  isRead            Boolean             @default(false)
  encrypted         Boolean             @default(false)
  encryptionVersion String?
  createdAt         DateTime            @default(now())
  updatedAt         DateTime?           @updatedAt
  content           String?
  receiverName      String?
  senderName        String?
  isGroup           Boolean             @default(false)
  deliveryAttempts  Int                 @default(0)
  persistedAt       DateTime?
  tempId            String?
  clientMessageId   String?             @db.VarChar
  gifUrl            String?
  contactName       String?
  contactPhone      String?
  contactEmail      String?
  contactAvatar     String?
  pollId            String?             @db.Uuid
  channel           Channel             @relation(fields: [channelId], references: [id], onDelete: Cascade)
  receiver          User?               @relation("ReceiverMessages", fields: [receiverId], references: [id], onUpdate: NoAction)
  sender            User                @relation("SenderMessages", fields: [senderId], references: [id], onDelete: Cascade, onUpdate: NoAction)
  poll              Poll?               @relation(fields: [pollId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_message_poll")
  attachments       MessageAttachment[]

  @@index([channelId])
  @@index([senderId])
  @@index([receiverId])
  @@index([isGroup])
  @@index([createdAt])
  @@index([status])
}

model Poll {
  id          String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  question    String
  type        String?      @default("single_choice")
  createdById String
  createdAt   DateTime?    @default(now()) @db.Timestamptz(6)
  updatedAt   DateTime?    @updatedAt @db.Timestamptz(6)
  message     Message[]
  createdBy   User         @relation("UserPolls", fields: [createdById], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_poll_created_by")
  PollOption  PollOption[]
}

model MessageAttachment {
  id        String  @id @default(uuid())
  messageId String
  url       String
  mimeType  String?
  meta      Json?
  size      Int?
  message   Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
}

model PollOption {
  id        String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  text      String
  pollId    String     @db.Uuid
  voteCount Int?       @default(0)
  Poll      Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_poll_option_poll")
  votes     PollVote[]
}

model PollVote {
  id         String     @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  voterId    String
  optionId   String     @db.Uuid
  createdAt  DateTime?  @default(now()) @db.Timestamptz(6)
  User       User       @relation(fields: [voterId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_poll_vote_voter")
  PollOption PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade, onUpdate: NoAction, map: "fk_poll_vote_option")

  @@unique([voterId, optionId], map: "unique_vote")
}

model User {
  id               String               @id(map: "User_pkey")
  name             String
  avatar           String?
  email            String?              @unique(map: "User_email_key")
  createdAt        DateTime             @default(now())      
  updatedAt        DateTime                                  
  isActive         Boolean?             @default(true)
  deletedAt        DateTime?            @db.Timestamp(6)     
  ownedChannels    Channel[]            @relation("ChannelOwner")
  channels         ChannelParticipant[]
  receivedMessages Message[]            @relation("ReceiverMessages")
  sentMessages     Message[]            @relation("SenderMessages")
  pollsCreated     Poll[]               @relation("UserPolls")
  PollVotes        PollVote[]
}

enum MessageType {
  text
  image
  emoji
  file
  audio
  video
  system
  reply
  reaction
  sticker
  location
  contact
  poll
  gif
}

enum ChannelType {
  direct
  group
  system
}

enum MemberRole {
  owner
  admin
  member
  guest
}

enum MemberStatus {
  joined
  left
  removed
}
